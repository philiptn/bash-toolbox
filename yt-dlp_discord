#!/usr/bin/env bash

# Text color definitions
BLUE="\e[34m"
GREEN="\e[32m"
RED="\e[31m"
YELLOW="\e[1;33m"
ENDCOL="\e[0m"

max_res="res:480" # 480p max resolution
target_size_mb=7 # 8MB target size, but 1MB headroom
target_audio_bitrate=96 # 128kbps target audio bitrate
audio_only=0
crop=0
cropvalue="crop=iw:ih:(in_w-out_w)/2:(in_h-out_h)/2"
verbose="--no-warnings"
ffmpeg_enable=1
ffmpeg_loglevel="-loglevel quiet -stats"

# Delete .tmp folder in case any previous downloads failed
rm -rf .tmp

# Thanks to 'Chris Pearson' (Aug 15, 2020) for getopts example
# https://stackoverflow.com/a/40190976

while [ $OPTIND -le "$#" ]
do
    if getopts navc option
    then
        case $option
        in
            n) target_size_mb=38  # 40MB target size, but 2MB headroom
               target_audio_bitrate=256 # 256kbps target audio bitrate
               ;;
            a) audio_only=1
               ;;
	    v) verbose="--verbose"
               ffmpeg_loglevel="-loglevel info"
               ;;
	    c) crop=1
               ;;
        esac
    else
        script_args+=("${!OPTIND}")
        ((OPTIND++))
    fi
done

# Thanks to 'tobek' (Jul 14, 2020) for duration and bitrate calculation examples
# https://unix.stackexchange.com/a/598360

target_size=$(($target_size_mb * 1000 * 1000 * 8)) # target size in bits
duration=$(yt-dlp --no-warnings --print duration ${script_args[@]})
duration_round_up=$((${duration%.*} + 1))

total_bitrate=$(($target_size / $duration_round_up))
audio_bitrate=$(($target_audio_bitrate * 1000))
video_bitrate=$(($total_bitrate - $audio_bitrate))

# If calculated video bitrate is less than 1kbps, throw error
if [[ ! $video_bitrate -gt 1000 ]]
then
   echo -e "${RED}ERROR:${ENDCOL} Video is too long to be compressed."
   exit 1
fi

yt_dlp_params="-S ${max_res}"
alt_params="--format bestaudio --extract-audio --audio-format mp3 --audio-quality $(($total_bitrate / 1000))k"

if [ "$audio_only" = "1" ]
then 
   ffmpeg_enable=0
   yt_dlp_params=$alt_params
fi

################
### DOWNLOAD ###
################

mkdir .tmp
yt-dlp ${verbose} ${yt_dlp_params} --output '.tmp/%(title)s.%(ext)s' ${script_args[@]}

####################
### CALCULATIONS ###
####################

file=$(find .tmp -type f | cut -d "/" -f 2)
file_no_ext=$(find .tmp -type f | cut -d "/" -f 2 | cut -d "." -f 1)

if [[ "$crop" = "1" ]]
then
   echo -e "[FFmpeg] ${YELLOW}Auto-cropping enabled.${ENDCOL}"
   # Detect black bars
   cropvalue_bb_initial=$(ffmpeg -i ".tmp/$file" -t 1 -vf "cropdetect=20:2:0" -f null - 2>&1 | awk '/crop/ { print $NF }' | tail -1)
   cropvalue_bb_seek=$(ffmpeg -ss 5 -i ".tmp/$file" -t 1 -vf "cropdetect=20:2:0" -f null - 2>&1 | awk '/crop/ { print $NF }' | tail -1)
  
   # Detect white bars
   cropvalue_wb_initial=$(ffmpeg -i ".tmp/$file" -t 1 -vf "lutrgb=r=negval:g=negval:b=negval, cropdetect=20:2:0" -f null - 2>&1 | awk '/crop/ { print $NF }' | tail -1)
   cropvalue_wb_seek=$(ffmpeg -ss 5 -i ".tmp/$file" -t 1 -vf "lutrgb=r=negval:g=negval:b=negval, cropdetect=20:2:0" -f null - 2>&1 | awk '/crop/ { print $NF }' | tail -1)
  
   # If the calculated crop-value is identical from the start of the video and 5 seconds in, apply crop value.
   if [[ "$cropvalue_bb_initial" = "$cropvalue_bb_seek" ]]
   then
      cropvalue=$cropvalue_bb_seek
   fi
   
   if [[ "$cropvalue_wb_initial" = "$cropvalue_wb_seek" ]]
   then
      cropvalue=$cropvalue_wb_seek
   fi
fi

if [[ "$audio_only" = "1" ]]
then
   mv ".tmp/$file" "./$file"
   rm -rf .tmp
fi

# If video duration is not available (Instagram Reels), get video length from ffprobe instead
if [[ "$duration" = "NA" ]]
then
   duration=$(ffmpeg -i ".tmp/$file" 2>&1 | grep Duration | awk '{print $2}' | tr -d , | awk -F: '{ print ($1 * 3600) + ($2 * 60) + ($3)}')
   duration_round_up=$((${duration%.*} + 1))
fi

total_bitrate=$(($target_size / $duration_round_up))
audio_bitrate=$(($target_audio_bitrate * 1000))
video_bitrate=$(($total_bitrate - $audio_bitrate))

postprocessor_args_str="-b:v ${video_bitrate} -maxrate:v ${video_bitrate} -bufsize:v $((${target_size} / 20)) -vf "$cropvalue" -b:a ${audio_bitrate}"

# If calculated video bitrate is negative, make audio mono
if [[ ! $video_bitrate -gt 0 ]]
then
   postprocessor_args_str="-b:v ${video_bitrate} -maxrate:v ${video_bitrate} -bufsize:v $((${target_size} / 20)) -vf "$cropvalue" -b:a ${audio_bitrate} -ac 1"
fi

# If calculated video bitrate is still negative, set video and audio to absolute lowest values
if [[ ! $video_bitrate -gt 0 ]]
then
   audio_bitrate=$((10 * 1000)) # 10kbps audio bitrate
   video_bitrate=$(($total_bitrate - $audio_bitrate - 5 * 1000)) # 5kbps bitrate overhead
   # Mono audio, 8kHz (phone audio) sample rate and max res of 240p
   postprocessor_args_str="-b:v ${video_bitrate} -maxrate:v ${video_bitrate} -bufsize:v $((${target_size} / 20)) -vf "scale=-2:240, $cropvalue" -b:a ${audio_bitrate} -ar 8000 -ac 1"
fi

# If calculated video bitrate is less than 1kbps, throw error
if [[ ! $video_bitrate -gt 1000 ]]
then
   echo -e "${RED}ERROR:${ENDCOL} Video is too long to be compressed." 
   exit 1
fi

##############
### FFMPEG ###
##############

if [[ "$ffmpeg_enable" = "1" ]]
then
   echo "[FFmpeg] Converting video..."
   ffmpeg $ffmpeg_loglevel -i ".tmp/$file" $postprocessor_args_str "$file_no_ext.mp4" && rm ".tmp/$file" && rm -rf .tmp
fi

# Print debug info if verbose is enabled
if [[ "$verbose" = "--verbose" ]]
then
   echo "+------------+"
   echo -e "| ${YELLOW}DEBUG INFO${ENDCOL} |"
   echo "+------------+"
   echo -e "${YELLOW}Duration (s):${ENDCOL} $duration"
   echo -e "${YELLOW}Duration round-up (s):${ENDCOL} $duration_round_up"
   echo -e "${YELLOW}Target size (bits):${ENDCOL} $target_size"
   echo -e "${YELLOW}Total bitrate (bits):${ENDCOL} $total_bitrate"
   echo -e "${YELLOW}Video bitrate (bits):${ENDCOL} $video_bitrate"
   echo -e "${YELLOW}Audio bitrate (bits):${ENDCOL} $audio_bitrate"
   echo -e "${YELLOW}Cropvalue black bars initial:${ENDCOL} $cropvalue_bb_initial"
   echo -e "${YELLOW}Cropvalue black bars seek:${ENDCOL} $cropvalue_bb_seek"
   echo -e "${YELLOW}Cropvalue white bars initial:${ENDCOL} $cropvalue_wb_initial"
   echo -e "${YELLOW}Cropvalue white bars seek:${ENDCOL} $cropvalue_wb_seek"
   echo -e "${YELLOW}Cropvalue (FINAL):${ENDCOL} $cropvalue"
   echo -e "${YELLOW}yt-dlp parameters (audio only):${ENDCOL} $alt_params"
   echo -e "${YELLOW}yt-dlp parameters (FINAL):${ENDCOL} $yt_dlp_params"
   echo -e "${YELLOW}FFmpeg arguments:${ENDCOL} $postprocessor_args_str"
fi

# If running script under WSL (Windows), automatically open explorer in current directory
if $(uname -a | grep -q 'microsoft')
then
   explorer.exe .
fi

